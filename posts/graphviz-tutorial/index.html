<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"}>
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

    <meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff" />
    <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1b" />

    <meta name="description" content="Automatic graph generation with Graphviz">

    
        <title>Automatic graph generation with Graphviz | Michele&#39;s Piece of Mind</title>
    

    
    <style>
        :root {
          --background: #ffffff;
        }
        @media (prefers-color-scheme: dark) {
          :root {
            --background: #1b1b1b;
          }
        }
        html {
            background-color: var(--background);
        }
        body {
            background-color: var(--background);
        }
    </style>

    
    <link rel="stylesheet" type="text/css" href="/style.min.375e5ed55aac1492efe66cf6fd686d0af88cb56b12d6bafab6571d3b39c73883.css" media="all">
  </head>

  <body>
        
        <nav>
          <ul class="menu">
            
                <li><a tabindex="-1" class="menu-link" href="/"><u>H</u>ome</a></li>
            
                <li><a tabindex="-1" class="menu-link" href="/tags"><u>T</u>ags</a></li>
            
          </ul>
        </nav>
        




<div id="single-header">
  <h1>
    Automatic graph generation with Graphviz
  </h1>
  <div id="single-meta">
    
    
        <span class="datesub">Mar 13, 2025 &nbsp;&nbsp; m. Mar 14, 2025</span>
      

  </div>
</div>





<main><p>Visualizing data is a fantastic way to gain insights into a specific domain. In
some contexts, it would be beneficial to be able to <strong>generate a graph programmatically</strong>.</p>
<h2 id="graphviz">Graphviz</h2>
<p><a href="https://graphviz.org/"  target="_blank" rel="noreferrer nofollow">Graphviz</a>
 is a graph visualization tool (I bet you wouldn&rsquo;t have guessed that, would you?).
It reads a textual description of a graph written in its Domain Specific Language, called
<a href="https://graphviz.org/doc/info/lang.html"  target="_blank" rel="noreferrer nofollow">DOT</a>
, and is capable of producing various output formats, including images.</p>
<p>The fact that it reads from a simple text file (or from <code>stdin</code>) opens the door
for all sorts of integrations and automations.</p>
<p>Some relevant use cases can be found in the description of the debian <code>graphviz</code> package.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">Automatic generation of graph drawings has important applications in key
</span></span><span class="line"><span class="cl">technologies such as database design, software engineering, VLSI and
</span></span><span class="line"><span class="cl">network design and visual interfaces in other domains. Situations where
</span></span><span class="line"><span class="cl">these tools might be particularly useful include:
</span></span><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">* you would like to restructure a program and first need to understand
</span></span><span class="line"><span class="cl">the relationships between its types, procedures, and source files
</span></span><span class="line"><span class="cl">* you need to find the bottlenecks in an Internet backbone - not only
</span></span><span class="line"><span class="cl">individual links, but their relationships
</span></span><span class="line"><span class="cl">* you&#39;re debugging a protocol or microarchitecture represented as a
</span></span><span class="line"><span class="cl">finite state machine and need to figure out how a certain
</span></span><span class="line"><span class="cl">error state arises
</span></span><span class="line"><span class="cl">* you would like to browse a database schema, knowledge base, or
</span></span><span class="line"><span class="cl">distributed program represented graphically
</span></span><span class="line"><span class="cl">* you would like to see an overview of a collection of linked documents
</span></span><span class="line"><span class="cl">* you would like to discover patterns and communities of interest in a
</span></span><span class="line"><span class="cl">database of telephone calls or e-mail messages
</span></span></code></pre></div><p>You can install Graphviz on Debian-based distributions with <code>apt install graphviz</code>.</p>
<h3 id="dot">DOT</h3>
<p>At its core, the DOT format allows you to specify node and edge definitions. Let&rsquo;s see a simple example.</p>
<pre tabindex="0"><code class="language-dot" data-lang="dot">graph {
    &#34;node-a-id&#34; [label=&#34;Node A Label&#34;]      // Node A properties
    &#34;node-a-id&#34; -- &#34;node-b-id&#34;              // Node A - Node B edge
}
</code></pre><p>Node B does not have any properties specified, but it is mentioned as the end of an edge.</p>
<p>Using the <code>dotty</code> interactive graph editor (part of <code>graphviz</code>) we can visualize
the results and experiment with them. If called as <code>dotty -</code>, it reads from <code>stdin</code>
for a DOT specification.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s1">&#39;graph {
</span></span></span><span class="line"><span class="cl"><span class="s1">    &#34;node-a-id&#34; [label=&#34;Node A Label&#34;]
</span></span></span><span class="line"><span class="cl"><span class="s1">    &#34;node-a-id&#34; -- &#34;node-b-id&#34;
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span> <span class="p">|</span> dotty -
</span></span></code></pre></div><p><p class="imgp">
  <img loading="lazy" src="/graphviz-tutorial/dotty.png" alt="dotty"  />
</p>
</p>
<p>As we can see, Node B is displayed using its ID, as it does not have a label.</p>
<p>The output may be a bit rough, but <code>dotty</code> is a powerful tool for experimenting with Graphviz.
We can generate a better-looking graph using <code>dot</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s1">&#39;graph {
</span></span></span><span class="line"><span class="cl"><span class="s1">    &#34;node-a-id&#34; [label=&#34;Node A Label&#34;]
</span></span></span><span class="line"><span class="cl"><span class="s1">    &#34;node-a-id&#34; -- &#34;node-b-id&#34;
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span> <span class="p">|</span> dot -Tpng -o graph.png
</span></span></code></pre></div><p><p class="imgp">
  <img loading="lazy" src="/graphviz-tutorial/graph.png" alt="graph.png"  />
</p>
</p>
<h2 id="example">Example</h2>
<p>Let&rsquo;s see a simple example: we want to visualize a directory subtree to get an
idea of its content. Let&rsquo;s take into account <code>/etc/apt</code> directory (and let&rsquo;s
pretend that the program <code>tree</code> does not exist).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="o">(</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;graph {&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;rankdir=RL&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    find /etc/apt -printf <span class="s1">&#39;%p\t%h\t%f\n&#39;</span> <span class="p">|</span> awk -F <span class="s1">&#39;\t&#39;</span> <span class="s1">&#39;{
</span></span></span><span class="line"><span class="cl"><span class="s1">        printf &#34;\&#34;%s\&#34; [label=\&#34;%s\&#34;]\n&#34;, $1, $3;
</span></span></span><span class="line"><span class="cl"><span class="s1">        printf &#34;\&#34;%s\&#34; -- \&#34;%s\&#34;\n&#34;, $1, $2;
</span></span></span><span class="line"><span class="cl"><span class="s1">    }&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;}&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">)</span> <span class="p">|</span> dot -Tpng -o graph.png
</span></span></code></pre></div><p>Here&rsquo;s the result on my system:</p>
<p><p class="imgp">
  <img loading="lazy" src="/graphviz-tutorial/apt-graph.png" alt="&lt;code&gt;/etc/apt&lt;/code&gt; directory graph"  />
</p>
</p>
<p>Let&rsquo;s analyze each command one by one:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;graph {&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;rankdir=RL&#34;</span>
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;}&#34;</span>
</span></span></code></pre></div><p>These istructions print the configuration for opening and closing the graph object
and setting the proper direction of graph layout, so that files (leafs) are on the right.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">find /etc/apt -printf <span class="s1">&#39;%p\t%h\t%f\n&#39;</span>
</span></span></code></pre></div><p><code>find</code> scans the directory subtree of <code>/etc/apt</code> and prints for each file:</p>
<ul>
<li>The full path</li>
<li>The base directory path</li>
<li>The file name</li>
</ul>
<p>These are separated using a tab character (<code>\t</code>).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">awk -F <span class="s1">&#39;\t&#39;</span> <span class="s1">&#39;{
</span></span></span><span class="line"><span class="cl"><span class="s1">    printf &#34;\&#34;%s\&#34; [label=\&#34;%s\&#34;]\n&#34;, $1, $3;
</span></span></span><span class="line"><span class="cl"><span class="s1">    printf &#34;\&#34;%s\&#34; -- \&#34;%s\&#34;\n&#34;, $1, $2;
</span></span></span><span class="line"><span class="cl"><span class="s1">}&#39;</span>
</span></span></code></pre></div><p>We use full paths as node IDs and the file name as labels.
The edge links a file (or directory) with its parent directory.</p>
<p><code>awk</code> is used to parse the output of find. It reads from <code>stdin</code> and for each line
it prints two lines:</p>
<ul>
<li>A node definition:  <code>&quot;&lt;full-path&gt;&quot; [label=&quot;&lt;file name&gt;&quot;]</code></li>
<li>An edge definition: <code>&quot;&lt;full-path&gt;&quot; -- &quot;&lt;base-directory-path&gt;&quot;</code></li>
</ul>
<p>We use full paths as node IDs and file name as labels. The edge links a file
(or directory) with its parent directory.</p>
<h2 id="conclusions">Conclusions</h2>
<p>We just saw a very simple example of what Graphviz is capable of, but it can be used to generate
all kinds of arbitrarily complex graphs, as it supports a wide range of configuration options.
Its versatility allows users to create detailed visual representations tailored to specific
needs, making it an invaluable tool for various applications.</p>
<p>Besides its CLI interface, bindings for different programming languages are available.</p>
<p>Think about it next time you need a graph representation of something.</p>
</main>





<footer>
    <script src="https://giscus.app/client.js"
        data-repo="mnalli/mnalli.github.io"
        data-repo-id="R_kgDONO8wlA"
        data-category="Announcements"
        data-category-id="DIC_kwDONO8wlM4CqOHL"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="preferred_color_scheme"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
    </script>
</footer>

<br>

<footer>

<script defer>
  document.addEventListener("keydown", function (e) {
    if (document.activeElement.isContentEditable) {
      return false;
    }
    if (document.activeElement.tagName == "INPUT") {
      return false;
    }
    if (e.altKey || e.ctrlKey || e.shiftKey) {
      return false;
    }
    var key = e.key;
    if (key === "h") {
      e.preventDefault();
      e.stopPropagation();
      window.location.href = "/";
    } else if (key === "t") {
      e.preventDefault();
      e.stopPropagation();
      window.location.href = `https://${location.hostname}/tags`;
    } else if (key === "i") {
      e.preventDefault();
      e.stopPropagation();
      const inputs = document.querySelectorAll("input");
      for (let i = 0; i < inputs.length; i++) {
        if (inputs[i].offsetParent !== null) {
          inputs[i].selectionStart = inputs[i].selectionEnd =
            inputs[i].value.length;
          inputs[i].focus();
          break;
        }
      }
    }
    return false;
  });
</script>


<script defer>
  function throttle(fn, wait) {
    var time = Date.now();
    return function () {
      var now = Date.now()
      if (time + wait - now < 0) {
        fn();
        time = now;
      }
    };
  }

  function scrollHandler() {
    const anchors = Array.from(document.querySelectorAll("body h2, body h3"));

    function scrollCallback() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop;

      
      for (var i = 0; i < anchors.length; i++) {
        var anchorId = anchors[i].getAttribute("id");
        var link = document.querySelector(
          'nav ul li a[href="#' + anchorId + '"]',
        );
        if (link) {
          link.classList.remove("active-toc");
        }
      }

      
      for (var i = anchors.length - 1; i >= 0; i--) {
        var offsetTop = anchors[i].offsetTop;
        if (scrollTop > offsetTop - 75) {
          var anchorId = anchors[i].getAttribute("id");
          var link = document.querySelector(
            'nav ul li a[href="#' + anchorId + '"]',
          );
          if (link) {
            link.classList.add("active-toc");
            break;
          }
        }
      }
    }

    window.addEventListener(
      "scroll",
      throttle(scrollCallback, 200),
    );
  }
  setTimeout(scrollHandler, 100);
</script>

<script defer>
  function addCopyButtonToCodeBlocks() {
    
    const codeBlocks = document.querySelectorAll('code[class^="language-"]');

    codeBlocks.forEach((codeBlock) => {
      const copyButton = document.createElement("button");
      copyButton.classList.add("copy-code-button");
      copyButton.innerHTML = "copy";

      
      copyButton.addEventListener("click", () => {
        
        const elements = codeBlock.querySelectorAll(".cl");
        let codeToCopy = "";
        elements.forEach((element) => {
          codeToCopy += element.innerText;
        });
        navigator.clipboard.writeText(codeToCopy);

        
        copyButton.innerHTML = "copied!";
        setTimeout(() => {
          copyButton.innerHTML = "copy";
        }, 1500);
      });

      
      codeBlock.parentNode.before(copyButton);
    });
  }
  setTimeout(function () {
    addCopyButtonToCodeBlocks();
  }, 100);
</script>

<script>
window.store = {
    
    "https:\/\/mnalli.github.io\/posts\/express-interactive-repl\/": {
        "title": "Express.js Interactive REPL",
        "tags": [],
        "content": "Introduction Having an interactive REPL is one of those things that makes experimenting and debugging so much nicer. Django has it built-in, through the manage.py shell command. This is basically the Python REPL with Django context preloaded. Express does not have anything like that built-in, but it is easy to implement it.\nAll code snippets shown will reference this tutorial project.\nTL;DR # javascript node --interactive --eval \u0026#34;`cat init-context.js`\u0026#34; # typescript ts-node --interactive --eval \u0026#34;`cat init-context.js`\u0026#34; Programmatically The approach I\u0026rsquo;ve seen the most online, for example in this article, is to instantiate the REPL programmatically, using the repl module. Following the aforementioned article, we may start up a Javascript REPL using the following script.\n#!/usr/bin/env node const repl = require(\u0026#34;repl\u0026#34;); const mongoose = require(\u0026#34;mongoose\u0026#34;); // app and configuration const app = require(\u0026#34;./app.js\u0026#34;); // Mongoose models const Author = require(\u0026#34;./models/author.js\u0026#34;); const Book = require(\u0026#34;./models/book.js\u0026#34;); const BookInstance = require(\u0026#34;./models/bookinstance.js\u0026#34;); const Genre = require(\u0026#34;./models/genre.js\u0026#34;); const mongoDB = \u0026#34;mongodb://localhost:27017/local_library\u0026#34;; async function main() { await mongoose.connect(mongoDB); process.stdout.write(\u0026#34;Database and Express app initialized.\\n\u0026#34;); const r = repl.start(); // set context r.context.app = app; r.context.Author = Author; r.context.Book = Book; r.context.BookInstance = BookInstance; r.context.Genre = Genre; r.on(\u0026#34;exit\u0026#34;, () =\u0026gt; { process.exit(); }); r.setupHistory(\u0026#34;.shell_history\u0026#34;, () =\u0026gt; {}); } main().catch(console.error); It took me some time to understand how to start a Typescript REPL instead. This is possible using the repl and ts-node modules combined, as shown below.\n#!/usr/bin/env node const repl = require(\u0026#34;repl\u0026#34;); const tsnode = require(\u0026#34;ts-node\u0026#34;); const mongoose = require(\u0026#34;mongoose\u0026#34;); // app and configuration const app = require(\u0026#34;./app.js\u0026#34;); // Mongoose models const Author = require(\u0026#34;./models/author.js\u0026#34;); const Book = require(\u0026#34;./models/book.js\u0026#34;); const BookInstance = require(\u0026#34;./models/bookinstance.js\u0026#34;); const Genre = require(\u0026#34;./models/genre.js\u0026#34;); const mongoDB = \u0026#34;mongodb://localhost:27017/local_library\u0026#34;; async function main() { await mongoose.connect(mongoDB); process.stdout.write(\u0026#34;Database and Express app initialized.\\n\u0026#34;); const tsrepl = tsnode.createRepl(); const service = tsnode.create({ ...tsrepl.evalAwarePartialHost }); tsrepl.setService(service); const r = repl.start({ eval: tsrepl.nodeEval }); // set context r.context.app = app; r.context.Author = Author; r.context.Book = Book; r.context.BookInstance = BookInstance; r.context.Genre = Genre; r.on(\u0026#34;exit\u0026#34;, () =\u0026gt; { process.exit(); }); r.setupHistory(\u0026#34;.shell_history\u0026#34;, () =\u0026gt; {}); } main().catch(console.error); Leveraging the command line While fidgeting with this last script I realized there is a much simpler way that leverages the standard REPL executables: node and ts-node.\nThis approach mocks the -i option of the python REPL. When this option is given, the REPL will execute the script (or the command if -c is used) and then enter interactive mode.\nnode and ts-node do not allow this kind of behavior, so if we try to do something like node -i init-context.js the REPL will just hang. What we can do is to evaluate the content of the file and enter interactive mode, as follows.\n# javascript node -i -e \u0026#34;`cat init-context.js`\u0026#34; # typescript ts-node -i -e \u0026#34;`cat init-context.js`\u0026#34; // init-context.js console.log(\u0026#39;Initializing db and express app...\u0026#39;); const mongoose = require(\u0026#34;mongoose\u0026#34;); // app and configuration const app = require(\u0026#39;./app.js\u0026#39;); // Mongoose models const Author = require(\u0026#39;./models/author.js\u0026#39;); const Book = require(\u0026#39;./models/book.js\u0026#39;); const BookInstance = require(\u0026#39;./models/bookinstance.js\u0026#39;); const Genre = require(\u0026#39;./models/genre.js\u0026#39;); mongoose.connect(\u0026#34;mongodb://localhost:27017/local_library\u0026#34;) .catch(console.error); We can define helper scripts, so that we can launch a shell with npm run shell.\n// package.json \u0026#34;scripts\u0026#34;: { \u0026#34;shell\u0026#34;: \u0026#34;node -i -e \\\u0026#34;`cat init-context.js`\\\u0026#34;\u0026#34;, \u0026#34;ts-shell\u0026#34;: \u0026#34;npx ts-node -i -e \\\u0026#34;`cat init-context.js`\\\u0026#34;\u0026#34; }, Conclusions This works nicely and it is not bound in any way to express. It is rather a way of initializing your REPL context.\n", 
        "url": "https:\/\/mnalli.github.io\/posts\/express-interactive-repl\/"
    },
    
    "https:\/\/mnalli.github.io\/posts\/": {
        "title": "Posts",
        "tags": [],
        "content": "", 
        "url": "https:\/\/mnalli.github.io\/posts\/"
    },
    
    "https:\/\/mnalli.github.io\/posts\/graphviz-tutorial\/": {
        "title": "Automatic graph generation with Graphviz",
        "tags": [],
        "content": "Visualizing data is a fantastic way to gain insights into a specific domain. In some contexts, it would be beneficial to be able to generate a graph programmatically.\nGraphviz Graphviz is a graph visualization tool (I bet you wouldn\u0026rsquo;t have guessed that, would you?). It reads a textual description of a graph written in its Domain Specific Language, called DOT , and is capable of producing various output formats, including images.\nThe fact that it reads from a simple text file (or from stdin) opens the door for all sorts of integrations and automations.\nSome relevant use cases can be found in the description of the debian graphviz package.\nAutomatic generation of graph drawings has important applications in key technologies such as database design, software engineering, VLSI and network design and visual interfaces in other domains. Situations where these tools might be particularly useful include: . * you would like to restructure a program and first need to understand the relationships between its types, procedures, and source files * you need to find the bottlenecks in an Internet backbone - not only individual links, but their relationships * you\u0026#39;re debugging a protocol or microarchitecture represented as a finite state machine and need to figure out how a certain error state arises * you would like to browse a database schema, knowledge base, or distributed program represented graphically * you would like to see an overview of a collection of linked documents * you would like to discover patterns and communities of interest in a database of telephone calls or e-mail messages You can install Graphviz on Debian-based distributions with apt install graphviz.\nDOT At its core, the DOT format allows you to specify node and edge definitions. Let\u0026rsquo;s see a simple example.\ngraph { \u0026#34;node-a-id\u0026#34; [label=\u0026#34;Node A Label\u0026#34;] // Node A properties \u0026#34;node-a-id\u0026#34; -- \u0026#34;node-b-id\u0026#34; // Node A - Node B edge } Node B does not have any properties specified, but it is mentioned as the end of an edge.\nUsing the dotty interactive graph editor (part of graphviz) we can visualize the results and experiment with them. If called as dotty -, it reads from stdin for a DOT specification.\necho \u0026#39;graph { \u0026#34;node-a-id\u0026#34; [label=\u0026#34;Node A Label\u0026#34;] \u0026#34;node-a-id\u0026#34; -- \u0026#34;node-b-id\u0026#34; }\u0026#39; | dotty - As we can see, Node B is displayed using its ID, as it does not have a label.\nThe output may be a bit rough, but dotty is a powerful tool for experimenting with Graphviz. We can generate a better-looking graph using dot.\necho \u0026#39;graph { \u0026#34;node-a-id\u0026#34; [label=\u0026#34;Node A Label\u0026#34;] \u0026#34;node-a-id\u0026#34; -- \u0026#34;node-b-id\u0026#34; }\u0026#39; | dot -Tpng -o graph.png Example Let\u0026rsquo;s see a simple example: we want to visualize a directory subtree to get an idea of its content. Let\u0026rsquo;s take into account /etc/apt directory (and let\u0026rsquo;s pretend that the program tree does not exist).\n( echo \u0026#34;graph {\u0026#34; echo \u0026#34;rankdir=RL\u0026#34; find /etc/apt -printf \u0026#39;%p\\t%h\\t%f\\n\u0026#39; | awk -F \u0026#39;\\t\u0026#39; \u0026#39;{ printf \u0026#34;\\\u0026#34;%s\\\u0026#34; [label=\\\u0026#34;%s\\\u0026#34;]\\n\u0026#34;, $1, $3; printf \u0026#34;\\\u0026#34;%s\\\u0026#34; -- \\\u0026#34;%s\\\u0026#34;\\n\u0026#34;, $1, $2; }\u0026#39; echo \u0026#34;}\u0026#34; ) | dot -Tpng -o graph.png Here\u0026rsquo;s the result on my system:\nLet\u0026rsquo;s analyze each command one by one:\necho \u0026#34;graph {\u0026#34; echo \u0026#34;rankdir=RL\u0026#34; ... echo \u0026#34;}\u0026#34; These istructions print the configuration for opening and closing the graph object and setting the proper direction of graph layout, so that files (leafs) are on the right.\nfind /etc/apt -printf \u0026#39;%p\\t%h\\t%f\\n\u0026#39; find scans the directory subtree of /etc/apt and prints for each file:\nThe full path The base directory path The file name These are separated using a tab character (\\t).\nawk -F \u0026#39;\\t\u0026#39; \u0026#39;{ printf \u0026#34;\\\u0026#34;%s\\\u0026#34; [label=\\\u0026#34;%s\\\u0026#34;]\\n\u0026#34;, $1, $3; printf \u0026#34;\\\u0026#34;%s\\\u0026#34; -- \\\u0026#34;%s\\\u0026#34;\\n\u0026#34;, $1, $2; }\u0026#39; We use full paths as node IDs and the file name as labels. The edge links a file (or directory) with its parent directory.\nawk is used to parse the output of find. It reads from stdin and for each line it prints two lines:\nA node definition: \u0026quot;\u0026lt;full-path\u0026gt;\u0026quot; [label=\u0026quot;\u0026lt;file name\u0026gt;\u0026quot;] An edge definition: \u0026quot;\u0026lt;full-path\u0026gt;\u0026quot; -- \u0026quot;\u0026lt;base-directory-path\u0026gt;\u0026quot; We use full paths as node IDs and file name as labels. The edge links a file (or directory) with its parent directory.\nConclusions We just saw a very simple example of what Graphviz is capable of, but it can be used to generate all kinds of arbitrarily complex graphs, as it supports a wide range of configuration options. Its versatility allows users to create detailed visual representations tailored to specific needs, making it an invaluable tool for various applications.\nBesides its CLI interface, bindings for different programming languages are available.\nThink about it next time you need a graph representation of something.\n", 
        "url": "https:\/\/mnalli.github.io\/posts\/graphviz-tutorial\/"
    },
    
    "https:\/\/mnalli.github.io\/posts\/ms-teams-chromium-pwa\/": {
        "title": "Install MS Teams for Linux as a PWA",
        "tags": [],
        "content": "On my work computer (Ubuntu 24.04) I had Microsoft Teams installed using flatpak , which is a wrapper around the webapp executed in chromium. As I have two accounts (one for my company and one for my client), I would like to be able to have both accounts open at the same time. I solved this issue by running a second instance of the webapp directly in chromium (not my main browser), in app mode (using the --app switch).\nThe other day, I realized there is a much cleaner and much more consistent way of doing this, installing it as a Progressive Web Applications (PWAs) with chromium.\nPWAs PWAs are web apps that provide a native feel, providing features such as offline access and push notifications. PWAs use standard web technologies (HTML, CSS and JavaScript).\nMicrosoft Teams on chromium Go to Microsoft Teams Web and login. Clicking on the three dots in the top-right corner you should see a drop down menu, as in the picture.\nClick on \u0026ldquo;Install Microsoft Teams\u0026rdquo;.\nNow, you will see that a desktop entry is created under ~/.local/share/applications. This effectively means that you will be able to search for \u0026ldquo;Microsoft Teams\u0026rdquo; in the application menu. If you open the desktop entry file using a text editor, you will see that the entry is nothing more than chromium wrapping a PWA.\n#!/usr/bin/env xdg-open [Desktop Entry] Version=1.0 Terminal=false Type=Application Name=Microsoft Teams Exec=/snap/bin/chromium --profile-directory=Default --app-id=cifhbcnohmdccbgoicgdjpfamggdegmo Icon=chrome-cifhbcnohmdccbgoicgdjpfamggdegmo-Default StartupWMClass=crx_cifhbcnohmdccbgoicgdjpfamggdegmo Installing a second instance To run two instances with different profiles, it is necessary to use two different browser profile, otherwise it won\u0026rsquo;t work.\nAfter having switched to another profile (create one if you need to), do the same process over again, installing another PWA. After this you would have two applications called \u0026ldquo;Microsoft Teams\u0026rdquo;. Opening the desktop entry with a text editor, you can simply modify their titles, so that you will be able to distinguish them.\nUninstalling If you wish to uninstall it, you can do so by launching the app and click on the three dots in the top-right corner.\nWrapping up Adopting this solution, I fixed a couple of issues that I had with my flatpak package, such as problems when sharing the screen and inconsistent notifications. This way it is all handled consistently through chromium.\n", 
        "url": "https:\/\/mnalli.github.io\/posts\/ms-teams-chromium-pwa\/"
    },
    
    "https:\/\/mnalli.github.io\/posts\/ms-intune-ubuntu\/": {
        "title": "Microsoft Intune on Ubuntu 24.04 LTS",
        "tags": [],
        "content": "As we can see in the official installation guide , as of today 25/11/2024, the Microsoft Intune app is not available for Ubuntu 24.04 (noble).\nWe can verify this by searching for intune-platform in the package list of microsoft repository for Ubuntu 22.04 and 24.04:\njammy: https://packages.microsoft.com/ubuntu/22.04/prod/dists/jammy/main/binary-amd64/Packages noble: https://packages.microsoft.com/ubuntu/24.04/prod/dists/noble/main/binary-amd64/Packages As of today, you will find it only in the first one.\nFollow the official installation guide for Ubuntu 22.04, then come back here.\nHey! Nice to see you again :)\nInstall intune-portal # ignore recommendations, i.e. microsoft edge sudo apt install intune-portal --no-install-recommends This will fail due to two dependencies that are not present on noble:\nlibjavascriptcoregtk-4.0 libwebkit2gtk-4.0 On noble only the updated versions are present:\nlibjavascriptcoregtk-4.1 libwebkit2gtk-4.1 Change the file /etc/apt/sources.list.d/ubuntu.sources by adding the following lines:\n## The following are only required because of intune-portal (not packaged for noble) ## libjavascriptcoregtk-4.0-18 libwebkit2gtk-4.0-37 Types: deb URIs: http://archive.ubuntu.com/ubuntu Suites: jammy jammy-updates Components: main universe restricted multiverse Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg ## Ubuntu security updates. Aside from URIs and Suites, ## this should mirror your choices in the previous section. Types: deb URIs: http://security.ubuntu.com/ubuntu/ Suites: jammy-security Components: main universe restricted multiverse Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg This will add jammy repositories.\nWARNING: mixing repositories from different distributions it is usually not a good idea and must be done carefully. Use jammy repositories only in this case and do not install other packages from it. When you install new packages check carefully what apt will do in advance.\nsudo apt update sudo apt install intune-portal --no-install-recommends Try to start Intune:\nintune-portal The app should start, but this does not mean that it would work correctly. Try to follow this tutorial.\nKeep an eye on systemd journal for error logs:\njournalctl -xe If everything goes well, great! Otherwise go on.\nInstall Java 11 JRE As suggested in this tutorial , we have to install openjdk-11-jre. If this is the case, you should see some relevant errors in systemd journal logs.\nsudo apt install openjdk-11-jre Log out, log in and try to run the app again.\nIf everything goes well, great! Otherwise go on.\ngnome-keyring In systemd journal logs you may read some errors related to a missing default keyring. This is especially likely if, like me, you are not using Gnome as desktop environment (I use KDE).\nAs we can see, intune-portal depends on gnome-keyring.\napt depends intune-portal To manage Gnome keyrings, install seahorse.\nsudo apt install seahorse seahorse Create a password keyring, then right-click it and \u0026ldquo;Set as default\u0026rdquo;. This is the keyring that will be used by Intune.\nAs last step, pray for it to be working and try again to complete the device enrollment .\n", 
        "url": "https:\/\/mnalli.github.io\/posts\/ms-intune-ubuntu\/"
    },
    
    "https:\/\/mnalli.github.io\/": {
        "title": "",
        "tags": [],
        "content": "Michele\u0026rsquo;s Piece of Mind ", 
        "url": "https:\/\/mnalli.github.io\/"
    },
    
    "https:\/\/mnalli.github.io\/categories\/": {
        "title": "Categories",
        "tags": [],
        "content": "", 
        "url": "https:\/\/mnalli.github.io\/categories\/"
    },
    
    "https:\/\/mnalli.github.io\/tags\/": {
        "title": "Tags",
        "tags": [],
        "content": "", 
        "url": "https:\/\/mnalli.github.io\/tags\/"
    },
    
}
</script>


    <script defer src="/js/lunr.js"></script>
    <script defer src="/js/search.js"></script>


</footer>

</body>
</html>

